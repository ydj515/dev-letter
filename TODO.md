# Newsletter Automation TODO

## Phase 0: Groundwork

- [x] 정의: 하루에 카테고리별 한 건 발행 → 총 `INTEREST_CATEGORIES.length` 만큼 일별 순환 여부 결정
- [x] 현재 구독 정보(`Subscriber.interests`) 분석 및 중복 케이스 수집
- [x] Resend 요금제·발송 한도 확인하고 대량 발송 전략(배치/레이트 리밋) 정리
- [x] Gemini 사용 시 예상 토큰/비용 산정, 프롬프트 설계 가이드 초안 작성

## Phase 1: 데이터 모델링 & 마이그레이션

- [x] Prisma 스키마 확장
  - [x] `NewsletterIssue`: 카테고리별 발행 콘텐츠를 저장하며 생성/발송 상태를 추적 (`publishDate` 유니크 제약 포함)
  - [x] `IssueDelivery`: 특정 이슈가 어떤 구독자에게 발송되었는지와 성공/실패 로그를 기록 (`status`, `sentAt`, 오류 메시지)
  - [x] `Subscriber` 확장: 최근 발송 시각과 선호 발송 시간 필드를 도입하고 발송 로그 관계 설정
- [x] 마이그레이션 작성 및 샘플 데이터 삽입 스크립트 준비
- [x] Prisma 클라이언트 업데이트 및 타입 영향도 점검

## Phase 2: AI 콘텐츠 생성 파이프라인

- [x] 카테고리별 프롬프트 템플릿 정의(질문 수, 톤, 포맷 포함)
- [x] Gemini 호출 유틸(`/lib/ai.ts` 등) 구현: 재시도·타임아웃·코스트 로깅
- [x] 생성 결과 정규화(JSON→배열) 및 필요 시 후처리(길이, 금칙어 필터)
- [x] `NewsletterIssue` 생성 서비스 작성
  - [x] 일자/카테고리 기준 중복 생성 방지
  - [x] 실패 시 fallback 컨텐츠/재시도 전략 마련
- [x] 질문/답변 세트(qaPairs)로 콘텐츠 저장 및 후처리 로직 보완
- [x] 인수 테스트: 목킹된 Gemini로 안정성 검증

## Phase 3: 스케줄링 & 잡 인프라

- [x] 일별 카테고리 선택 규칙 구현(예: 순환, 고정 시간표, 사용자 맞춤)
- [x] Vercel Cron 또는 외부 워커 선택 및 환경 구성
  - [x] cron 잡이 Prisma/Resend에 접근할 수 있도록 환경 변수 주입
- [x] 잡 실행 플로우
  1. 전일 미발송 이슈 확인 및 재시도
  2. 오늘 발송 대상 카테고리 이슈 생성 및 저장
  3. 구독자 필터링(관심사 포함 + 구독 가능 상태)
  4. 발송 큐 등록
- [x] 로컬에서 스케줄러 수동 실행 스크립트(`npm run cron:send`) 추가

## Phase 4: 이메일 템플릿 & 발송 로직

- [x] React Email 기반 `DailyNewsletter` 템플릿 작성(카테고리, 질문 리스트, CTA 포함)
- [x] HTML + 텍스트 버전 렌더링 & 스팸 필터 대응 설정
- [x] Resend 발송 유틸 구축(배치 처리, 오류 로깅, 재시도 정책)
- [x] 발송 결과를 `IssueDelivery`에 기록하고 실패 시 재발송 큐 재등록
- [x] 수신 거부 링크 연결(구독 취소 API + 추적 토큰)

## Phase 5: 관리 도구 & 관측성

- [x] 관리자용 대시보드/페이지(Next.js) 구축: 생성된 이슈 미리보기·승인·재발송·즉시 콘텐츠 생성
- [x] 로그/알림: Slack 혹은 이메일로 실패 알림 전송
- [x] Metrics 수집(발송 성공률, 오픈/클릭 추후 추가 가능)
- [x] 감사 로그: 누가 어떤 이슈를 수동으로 보냈는지 기록

## Phase 6: 테스트 & 운영 준비

- [ ] 유닛 테스트: AI 유틸, 스케줄러, 발송 유틸 Mock 기반 검증
- [ ] 통합 테스트: 테스트 DB + Resend mock 서버 연동
- [ ] QA 체크리스트 작성(템플릿 깨짐, 시간대 검증, 구독 취소 플로우)
- [ ] 문서화 업데이트(README에 자동 발행 섹션, 운영 가이드)
- [ ] 점진적 롤아웃 계획 수립(내부 계정 → 제한된 사용자 → 전체)
